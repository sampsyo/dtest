#!/usr/bin/env python
from __future__ import print_function

import sys
import struct
from scipy.stats import ks_2samp
import random


# TODO: Undo copypasta.
def rowgen(kind, dims, args):
    if kind == 'uniform':
        min, max = [float(a) for a in args]
        out = []
        for i in range(dims):
            out.append(random.uniform(min, max))
        return out

    else:
        raise Exception('unknown distribution kind {}'.format(kind))


def unpack_advance(fmt, buffer, offset):
    """Unpack a string from a buffer. Return the unpacked values and the
    new offset.
    """
    res = struct.unpack_from(fmt, buffer, offset)
    return res, offset + struct.calcsize(fmt)


def parse_packed_floats(buffer):
    """Parse the data format generated by `distgen` for this
    application.
    """
    offset = 0
    rows = []
    while offset < len(buffer):
        (length,), offset = unpack_advance('i', buffer, offset)
        row, offset = unpack_advance('%sf' % length, buffer, offset)
        rows.append(row)
    return rows


def project(vecs, index):
    """Given a sequence of vectors, project one dimension into a
    sequence of single values.
    """
    for vec in vecs:
        yield vec[index]


def test_vectors(vecs, kind, dims, args):
    # Generate data from the appropriate distribution.
    synthetic = []
    for i in range(len(vecs)):
        synthetic.append(rowgen(kind, dims, args))

    # Test for similarity in each dimension.
    p_values = []
    for index in range(dims):
        synthetic_proj = list(project(synthetic, index))
        vecs_proj = list(project(vecs, index))
        _, p = ks_2samp(synthetic_proj, vecs_proj)
        p_values.append(p)
    # print(p_values, file=sys.stderr)
    return sum(p_values)


def disttest(infile, args):
    rows = parse_packed_floats(infile.read())
    score = test_vectors(rows, args[0], int(args[1]), map(float, args[2:]))
    print(score)


if __name__ == '__main__':
    disttest(sys.stdin, sys.argv[1:])
